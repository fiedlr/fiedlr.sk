<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="Adam Fiedler">
    <title>Warning! Code Can Be Explosive | Adam Fiedler</title>
    <meta name="description" content="We don’t want bugs in our code, period. Bugs are not only annoying, they can cost us millions of dollars if they go unnoticed. No matter how hard we try, every time we remove a bug, another pops up in a seemingly unrelated part of the code base.">
    <meta property="og:title" content="Warning! Code Can Be Explosive | Adam Fiedler">
    <meta property="og:description" content="We don’t want bugs in our code, period. Bugs are not only annoying, they can cost us millions of dollars if they go unnoticed. No matter how hard we try, every time we remove a bug, another pops up in a seemingly unrelated part of the code base.">
    <meta property="og:type" content="article">
    <meta property="og:article:author" content="Adam Fiedler">
    <meta property="og:url" content="https://fiedler.sk/verification/2022-11-02-warning-code-can-be-explosive.html">
    <meta property="og:image" content="https://fiedler.sk/images/og.jpg">
    <link rel="apple-touch-icon" href="../images/apple-touch-icon.png">
    <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&family=Source+Sans+Pro:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
    <link rel="stylesheet" type="text/css" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="../css/light.css?new=3">
    <link rel="stylesheet" type="text/css" href="../css/syntax.css">
    
    <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
    <![endif]-->
</head>
<body>
    <header>
        <div class="logo">
            <img src="../images/og.jpg" alt="A headshot of Adam Fiedler" class="round">
            <div class="caption">Adam Fiedler</div>
            <div class="social">
                <a class="em" href="mailto:info@fiedlr.com">
                    <i class="fa fa-envelope"><span class="sr-only">Write me an e-mail</span></i>
                </a>
                <a class="tw" href="https://twitter.com/fiedlr">
                    <i class="fa fa-twitter"><span class="sr-only">Tweet me</span></i>
                </a>
                <a class="li" href="https://linkedin.com/in/fiedlr">
                    <i class="fa fa-linkedin"><span class="sr-only">I'm on LinkedIn</span></i>
                </a>
                <a class="gh" href="https://github.com/fiedlr">
                    <i class="fa fa-github"><span class="sr-only">My GitHub projects</span></i>
                </a>
            </div>
        </div>
        <nav>
            <a href="../">Home</a>
            <a href="../opinion">Opinion</a> <a href="../programming">Programming</a> <a href="../verification">Verification</a>
            <a href="../publications">Publications</a>
            <a href="../about">About</a>
        </nav>
    </header>
    <main role="main">
        <div class="body">
            <div class="title">
                <h1>Warning! Code Can Be Explosive</h1>
            </div>
            <article>
    <section class="meta">
        Posted on November  2, 2022 in <a href="../verification">Verification</a>
        
        
        
    </section>
    <section class="body">
        
            
            
        
        <p>
<figure>
<img src="https://runtimeverification.com/assets/img/blog/warning-code-explosive.png" />
</figure>
</p>
<p>We don’t want bugs in our code, period. Bugs are not only annoying, they can cost us <a href="https://rekt.news/leaderboard/">millions of dollars</a> if they go unnoticed. No matter how hard we try, every time we remove a bug, another pops up in a seemingly unrelated part of the code base.</p>
<p>
<figure>
<img src="https://runtimeverification.com/assets/img/blog/lib-photograph.jpeg" alt="Source: U.S. Naval Historical Center Online Library Photograph NH 96566-KN" /><figcaption>Source: U.S. Naval Historical Center Online Library Photograph <a href="https://www.history.navy.mil/our-collections/photography/numerical-list-of-images/nhhc-series/nh-series/NH-96000/NH-96566-KN.html">NH 96566-KN</a></figcaption>
</figure>
</p>
<p>That is why we do <em>tests:</em> to make sure that the program works as expected when we type something in or interact in any other way. We have tests for everything: unit tests, property tests, visual tests, end-to-end tests, integration tests, smoke tests, stress/load testing, manual testing…<br />
We even do <em>regression testing</em> which checks whether our code updates broke the functionality that already worked in the past! In other words, we have learned to <em>live with tests</em>: we put little green badges in our repositories saying “100% test coverage” so that we can sleep peacefully, knowing that every part of our code was properly tested.</p>
<p>We might sleep peacefully until we come across the following quote:</p>
<blockquote>
<p>“… As we know, there are known knowns; there are things we know we know. We also know there are known unknowns; that is to say we know there are some things we do not know. But there are also unknown unknowns - the ones we don’t know we don’t know.” — Donald Rumsfeld [1]</p>
</blockquote>
<p>To put this in perspective, we know there are some bugs we need to fix (known knowns). We would also expect that if we handle a new feature in an ad hoc manner, it might later come to bite us (known unknowns). The worst kind of bugs, however, are those that we are <em>not</em> expecting (an unknown unknown), i.e., the core functionality we thought was bullet-proof and then tragically fails. In other words, when there’s an error in the functionality that has been <em>thoroughly tested</em>.</p>
<p>Rumsfeld’s thesis has also been extended with <a href="https://www.lacan.com/zizekrumsfeld.htm">the fourth category</a> [2], <em>the unknown knowns</em>: the suppositions we <em>pretend</em> not to know. There is an elephant in the room: tests are great only for catching bugs that we would expect. After all, we are testing only what we know might fail and only on inputs we assume to be critical. For other kinds of inputs, we assume they are handled automatically, whereas in reality, that is far from guaranteed. Much harm can be done if we fail to acknowledge this.</p>
<p>Despite all the tragedies, we have learned to live with the idea that for most applications, tests and Q&amp;A are enough. One can argue that tests have worked quite well for us and that the world cannot be perfect. Let us make a simple comparison, then. Would you walk on a bridge built of a new rock solid material, knowing that no external auditing or inspection was done, but a group of 20 vehicles rode on every square foot of its surface? The bridge was indeed “100% tested” for its use case. We only want it to stand still for passing vehicles. What happens when we get an unexpected input such as <a href="http://www.bridgesofdublin.ie/bridge-building/disasters/angers-bridge-france-1850"><em>resonance</em></a>? Well-written tests are great, but something that we forget to test might always crop up.</p>
<h2 id="when-tests-fail">When Tests Fail</h2>
<p>We are software engineers, so let us finally talk about engineering software and not bridges. All around us there’s software that powers critical systems. Sometimes we don’t even realize it. Mere fetching data from a user table can cause a leak that could make a company bankrupt. Not to mention smart contracts, which are nothing but programs that are executed if some predefined criteria are met. Mistakes can have severe consequences. We should always be writing code as if for our local nuclear power plant.</p>
<p>
<figure>
<img src="https://runtimeverification.com/assets/img/blog/emmelie-callewaert.jpeg" alt="© 2014 Emmelie Callewaert under CC BY-SA 4.0" /><figcaption>© 2014 <a href="https://commons.wikimedia.org/wiki/File:Kerncentrale_Doel_in_werking.jpg">Emmelie Callewaert</a> under <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.en">CC BY-SA 4.0</a></figcaption>
</figure>
</p>
<p>Imagine you actually are implementing a function for a nuclear power plant. There are n cooling towers that pump heat out of the reactor’s proximity. Your task is to program the logic which controls the cooling mechanism. Let us consider a simplified, hypothetical (and slightly distorted) scenario. The logic only controls how much water goes in based on the reactor’s temperature and decides how it is distributed among the towers. If there is too much water in the pipes, the reactor is too cold. The systems will not run efficiently, leading to waste. This may cause the towers to age poorly, and in the worst case, the pipes can break. If there is too little water in the pipes, well, we do not need to explain that part (the reactor melts).</p>
<p>Bear in mind that the reactor is a living organism, the situation changes every nanosecond. You cannot just type “allow this constant amount of water to pass”. What is more, there are several towers and only one reactor. That means you do not want one of the n towers to become overwhelmed and the rest remain idle.</p>
<p>How do we approach this? Well, we want to balance the temperature around some value and distribute the water among the towers as much evenly as possible, right? The first idea that comes to mind is a simple “linear balancer”. Say we calculate a water constant saying how much water we need per 1 degree. If the temperature changes by 1 degree, we simply add/remove the corresponding amount of water. With a little bit of foresight, we also realize that we cannot push a negative amount of water, so we also enforce that with the <code>min</code> function:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode typescript"><code class="sourceCode typescript"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">function</span> <span class="fu">getWaterAmount</span>(int last_temperature<span class="op">,</span> int temperature<span class="op">,</span> int last_amount)<span class="op">:</span> <span class="op">[</span>int<span class="op">]</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb1-2" title="2">      int amount <span class="op">=</span> <span class="fu">min</span>(<span class="dv">0</span><span class="op">,</span> last_amount <span class="op">+</span> (temperature <span class="op">-</span> last_temperature) <span class="op">*</span> WATER_CONSTANT)<span class="op">;</span></a>
<a class="sourceLine" id="cb1-3" title="3">      <span class="cf">return</span> <span class="op">[</span>amount / n<span class="op">,</span> …<span class="op">,</span> amount / n<span class="op">];</span></a>
<a class="sourceLine" id="cb1-4" title="4">  <span class="op">}</span></a></code></pre></div>
<p>Now we want to make sure this intuition works. Since it’s a power plant, we’ll allow that we use something more advanced such as <a href="https://en.wikipedia.org/wiki/Fuzzing">fuzzing</a>. Fuzzing is an automatic testing technique that chooses a set of inputs according to some predefined model. The model tries to find unexpected inputs that crash our program. We’ll try to use fuzzing to test the cooling mechanism we’ve just implemented.</p>
<p>Let’s assume that we have a magic function <code>getAverageTemperature([int] water)</code>, which correctly tells us what the reactor’s average temperature will be based on the amount of water. We’d like to test the straightforward property saying that the temperature won’t jump over either of the extremes by fuzzing the reactor state:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode typescript"><code class="sourceCode typescript"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">function</span> <span class="fu">test_temperature</span>()<span class="op">:</span> bool <span class="op">{</span></a>
<a class="sourceLine" id="cb2-2" title="2">    int temp <span class="op">=</span> <span class="fu">getAverageTemperature</span>(</a>
<a class="sourceLine" id="cb2-3" title="3">          <span class="fu">getWaterAmount</span>(fuzz_last_temp<span class="op">,</span> fuzz_temp<span class="op">,</span> <span class="fu">min</span>(fuzz_last_amount<span class="op">,</span> <span class="dv">0</span>))</a>
<a class="sourceLine" id="cb2-4" title="4">      )<span class="op">;</span></a>
<a class="sourceLine" id="cb2-5" title="5">    <span class="cf">return</span> LOW <span class="op">&lt;=</span> temp <span class="op">&lt;=</span> HIGH<span class="op">;</span></a>
<a class="sourceLine" id="cb2-6" title="6">  <span class="op">}</span></a></code></pre></div>
<p>After we run the test (starting in a balanced state), let’s say everything checks out and passes the above fuzz test. The question for the audience: is <code>getWaterAmount</code> bug-free? Would you feel safe knowing that your local power plant uses this function even after there are 20 other passing tests of it? Or 1000 high-quality tests? How many tests are enough? We are not testing just some random function. I guess one is starting to see that an easy problem turned into a complicated beast. And somehow the solution might seem too good to be true. After all, the average temperature stays normal… If you do not see any problems here, among the many questions you should be asking yourself:</p>
<ol>
<li><a href="#need-for-formal-verification">Do I really cover all important inputs?</a></li>
<li><a href="#audits">Should I consult other experts on my approach?</a></li>
</ol>
<h2 id="need-for-formal-verification">Need for Formal Verification</h2>
<p>One of the biggest challenges in writing good tests is that we do not know which inputs are important. We might overlook some very weird combinations of inputs. Fuzzing improves our chances in this respect because it can be effective in a systematic combing through the input space, but we are still the ones who somehow influence the <em>finite</em> choice of inputs.</p>
<p>What if instead of deciding which cases to cover, we could cover <em>all</em> cases at once? This is the idea behind <em>program verification</em>, which applies <a href="https://en.wikipedia.org/wiki/Formal_verification">formal verification</a> techniques on verifying correctness of programs. We <em>specify</em> exactly what it means for a program to be correct in advance, and then (algorithmically) <em>verify</em> that the program behaves on <em>all</em> inputs according to our specification. If we have a very good idea of what it means for our program to be 100% correct and the specification mirrors this faithfully, then (in theory) program verification can confirm that the program is 100% correct. This is because we are able to exercise our specification on <em>all</em> inputs and because the specification must hold everywhere we require it. This is different from testing: 100% test coverage can mean that we tested 1% of the inputs and some parts of the code base were tested on 0.00001% of the inputs.</p>
<p>The problem of writing good tests is thus reduced to the problem of writing good specifications. Are we jumping out of the frying pan to the fire? Not necessarily. In the following paragraphs, we will very briefly explain why.</p>
<h3 id="functional-correctness">Functional Correctness</h3>
<p>Let us quickly recall <a href="https://en.wikipedia.org/wiki/Correctness_(computer_science)">basic terms</a> from our Algorithms class. When analyzing algorithms, one usually specifies a <em>precondition</em> and a <em>postcondition</em>. A precondition is a formal statement saying for what inputs the algorithm should work – it is simply a list of assumptions about our input. A postcondition is a formal statement saying what conditions the output should satisfy.</p>
<p>We say that the algorithm is <em>partially correct</em> if a (potential) output satisfies the postcondition for any input satisfying the precondition. The algorithm is called <em>correct</em> if it is partially correct, and is guaranteed to halt. Now replace the term <em>algorithm</em> in all definitions with the word <em>program</em>. Voila, we get a very faint grasp of what it means that a program is correct. Faint because programs can be more complicated and that is why we need something more general than this.</p>
<h3 id="specifications">Specifications</h3>
<p>Specifications could be seen as a generalization of pre- and post-conditions. They are usually given in some specification language or logic and tell how a program should behave. Compared to tests, they can also be viewed as properties which have to be property-tested on all (usually infinitely many) inputs in order to be true.</p>
<p>As one can imagine, it is sometimes very hard to specify what we actually want. For example, what is the correct behavior of an operating system? That is why one of the most popular kinds of specifications are <em>reachability</em> claims. These are in essence always the same. We are interested in whether a program can reach a set of (error) states. Inputs for reachability conditions are usually <em>program runs</em>. In the case of the nuclear reactor software, we could specify something along these lines:</p>
<p><em>No run of the reactor software reaches the function <code>setOffMeltdownAlarm()</code>.</em></p>
<p>This is the idea of <a href="https://dl.acm.org/doi/10.1145/3022671.2984027">reachability logic</a>, which enables us to easily prove claims of this kind given a set of assumptions. Of course, we need to trust that the compiler and the verifier are correct. In embedded systems, we also have to trust that the physical device abides by its (software) model. This is ok: we are verifying the correctness of reactor software, not the reactor (interface) itself.</p>
<p>We can also specify much more complex conditions. For example, in <a href="http://www.matching-logic.org/">matching logic</a> and <a href="https://kframework.org/index.html">the K framework</a>, a program run is usually represented in terms of a sequence of <em>states</em>. A state is just a collection of data structures such as the function stack holding what function we are in and how we got there. Then we can specify reachability conditions with <em>respect</em> to program states, which gives us the expressiveness we need.</p>
<p>Writing specifications is a tedious process, but there are experts in this area. If you would like to come up with a set of specifications for your software, the easiest way to start is by contacting a <a href="https://runtimeverification.com/blog/category/audits">verification engineer</a> that will walk you through the entire process on-site. Let us assume now we have a good specification. Next, we want to <em>verify</em> that it holds, i.e., that our program behaves as specified, which is going to be covered next.</p>
<h3 id="verification">Verification</h3>
<p>A program verifier takes the program and specification as input, and ideally decides whether the program meets its specification. There are many techniques to achieve this and it is an active area of <a href="https://en.wikipedia.org/wiki/Formal_verification">research</a>. For example, in <em>deductive verification</em>, the system is modeled as a logical theory and the specification is a logical theorem to be proven. Proof obligations can be discharged in proof assistants, automatic tools such as SMT solvers, or a combination of both (where the user needs to fill in details when an automatic tool is stuck). Specifications can also be written as <em>annotations</em>, and <a href="https://dafny.org/">some languages</a> even require it for programs to compile successfully.</p>
<p><a href="https://kframework.org/index.html">The K framework</a> we’ve discussed generates a (semi-automatic) deductive verifier for proving reachability claims. Its main advantage over other verifiers is that it forces the interpreter and the verifier to <em>use the same semantics of the target programming language</em>. In simple terms, there is no translation to an intermediate model. The semantics of a language <em>are</em> a logical theory that you plug in. The K verifier works with the same machine code as the interpreter, and that is why it isn’t possible to get two different behaviors of the same program dependent on whether we use the interpreter or the verifier. This is a unique feature of the K framework: other verification methods usually rely on some intermediate or ad hoc representation of the program, which leaves room for error. For example, <a href="https://youtu.be/eSaIKHQOo4c?t=71">Grigore Rosu presented</a> the following simple program:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb3-1" title="1"><span class="dt">int</span> main(<span class="dt">void</span>) {</a>
<a class="sourceLine" id="cb3-2" title="2">    <span class="dt">int</span> x = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb3-3" title="3">    <span class="cf">return</span> (x = <span class="dv">1</span>) + (x = <span class="dv">2</span>);</a>
<a class="sourceLine" id="cb3-4" title="4">  }</a></code></pre></div>
<p>Even though the return value of <code>main</code> is in this case <em>undefined</em> <a href="https://dl.acm.org/doi/10.1145/2813885.2737979">according to the C standard</a>, <code>gcc4</code> returns <code>4</code>, <code>gcc3</code> returns <code>3</code>, and some formal verifiers “prove” it is still <code>4</code>! This is unacceptable in formal verification, which should give you absolute guarantees regardless of the used compiler. We are starting to see that verifiers should be based directly on the specification of programming languages: its <em>formal semantics</em>.</p>
<p>We can extend this principle even further. If both our compiler and verifier rely upon the same reference, formal semantics, then <em>program runs and proofs of reachability claims are the same thing</em>. When we want to claim that a program can reach some state, we provide a valid program run ending in this state as proof, which shows exactly how it can happen. The K verifier simply runs <a href="https://en.wikipedia.org/wiki/Symbolic_execution">symbolic execution</a> on a given program and tries to find such a run. If it successfully finds a run like this, then it confirms the reachability claim. If it does not find a run like this, it can reject the claim because symbolic execution examines all runs using symbolic inputs. The following snippet shows how <code>bug1()</code> cannot be reached by any run because the path condition about <code>n</code> is infeasible:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode typescript"><code class="sourceCode typescript"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">function</span> <span class="fu">foo</span>(int n) <span class="op">{</span></a>
<a class="sourceLine" id="cb4-2" title="2">    <span class="co">// n : int</span></a>
<a class="sourceLine" id="cb4-3" title="3">    <span class="fu">if</span> (n <span class="op">&gt;</span> <span class="dv">0</span>) <span class="op">{</span> <span class="co">// n : int &amp;&amp; n &gt; 0</span></a>
<a class="sourceLine" id="cb4-4" title="4">      <span class="fu">if</span> (n <span class="op">&lt;=</span> <span class="dv">0</span>) <span class="op">{</span> <span class="co">// n : int &amp;&amp; n &gt; 0 &amp;&amp; n &lt;= 0</span></a>
<a class="sourceLine" id="cb4-5" title="5">        <span class="fu">bug1</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb4-6" title="6">      <span class="op">}</span></a>
<a class="sourceLine" id="cb4-7" title="7">    <span class="op">}</span></a>
<a class="sourceLine" id="cb4-8" title="8">  <span class="op">}</span></a></code></pre></div>
<p>This simple example would probably also be caught by a linter, but symbolic execution can handle much more complicated cases. Symbolic inputs cover the entire input space of concrete inputs. This is a huge advantage over testing, which only works with a finite number of concrete inputs. A passed test of some property does not mean that the property holds for all inputs, only for the <em>tested inputs</em>. When a test does not find any evidence of an error, we cannot claim that the program is bug-free. With verification, we can.</p>
<p>The main takeaway from the K framework is that we do not need any intermediate representation of the program or the claim, we can work directly with the underlying code. When relying on other methods, correctness often depends on whether the representation of the program and the claim really correspond to the original! For each programming language, the translation can be different and complicated. In the K framework, we take the program <em>as is</em>, run it <em>as is</em>, and verify <em>as is</em>. Proofs are not abstract but very concrete because each tool for our language uses the same reference, its formal semantics written in the K language:</p>
<p>
<figure>
<img src="https://runtimeverification.com/assets/img/blog/k-framework-representation.png" />
</figure>
</p>
<p>One can argue that we may write an insufficient specification in the same way as we may write an insufficient test suite. Yes and no. Verification is, in a way, a generalization of testing, not an opposing technology. In an ideal world, we could only have specifications, which would also cover what we usually cover with tests. We would do <em>specification-driven development</em>: we would write specifications first to make sure we really understand what we want to do, and only then would we implement it.</p>
<p>However, verification and specification can be a time consuming process that usually takes more time than testing. The best option in critical systems is to run verification <em>on top of testing</em>. There is nothing preventing you from including verification in your Q&amp;A process. This can only have advantages: you do not have to throw away your tests and trust verification completely, you can have it as an extra layer of examination. Together with <em>audits</em>, which we are going to discuss next, this gives the best guarantees we can currently have in software.</p>
<h2 id="audits">Audits</h2>
<p>We are experts on code, not necessarily on the domain of our application. We should fight our every assumption as hard as we can, and when we are even slightly uncertain, we should consult an independent party. A power plant engineer would probably be horrified reading through the <code>getWaterAmount</code> example. There are red flags everywhere:</p>
<ul>
<li>How did you come up with that water constant?!</li>
<li>Can you really make decisions based on <em>local</em> state only <code>snippet</code>?!</li>
<li>Are you sure you want to use a linear function on an <em>exponentially behaving system</em>?!</li>
<li>You really want to test against an <em>average temperature metric</em>?! That is insane!</li>
<li>What happens when you want to pump more water than available?!</li>
<li>What happens when there is a memory overflow?!</li>
<li>How did you come to the conclusion that the water should be evenly distributed?!</li>
<li>How do you <em>schedule</em> the entire thing? There is a whole branch of computer science devoted to the analysis of real time systems. Timing is a huge source of bugs even in single processor scheduling.</li>
</ul>
<p>The list can go on and on. Sometimes we are so engulfed in our own solution that we start to overlook why it is wrong. We don’t have to write code for a power plant here. What if we have, for example, a financial product and we want to scale? Do we really not want to use any technique available to make sure we can? The best way to avoid self-deceit is to have an <em>independent audit</em> of our code.</p>
<h3 id="external-code-reviews">External code reviews</h3>
<p>Why do we need someone external to look at our private code and <em>pay</em> them to do it? We have our own security specialists… We can hire more of them if needed. The answer is that auditors are not there to replace a security team, but to <em>supplement</em> it. External auditors can assess risks independently without any peer pressure. Moreover, auditors have regular experience from multiple projects. That way they might spot something the security team is used to seeing even if it might be problematic.</p>
<p>If your audit firm is doing <em>white-paper reporting</em>, then you know you made the right choice. It means that problematic parts and bugs are discussed with your team on a regular basis. This is how it is supposed to be done: audit firms are selling services, not reports. Auditors also cannot do their work properly if they have no feedback from the developers. The better a codebase is devised, <a href="https://www.youtube.com/watch?v=GXU5Fd6gMVw&amp;t=17422s">the deeper auditors can actually investigate</a>. How does it work?</p>
<ol>
<li>The auditing team discusses with you the time plan and ideas about what needs to be checked.</li>
<li>You provide secure access to your repository.</li>
<li>The auditing team researches all your relevant materials and studies your code.</li>
<li>The auditing team creates an abstract model of your codebase and analyzes it.</li>
<li>The auditors refer to a database of known security flaws and check that your code does not suffer from any of them.</li>
<li>A report is written explaining all the findings and possible solutions. You can usually choose what goes public and what response you want to include. An example report can be found <a href="https://github.com/runtimeverification/publications/blob/main/reports/smart-contracts/Blockswap_Stakehouse.pdf">here</a>.</li>
</ol>
<p>If you’re still not convinced, there is a simple analogy. Imagine scientific papers are not peer-reviewed, only double-checked by the research team members. Would you trust the results as much as if they were published in a top journal that verifies every claim an author makes? External companies auditing your code give you another level of guarantees and trust. That is something you cannot achieve with your team alone.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Tests are great if we know exactly what to test. Unfortunately, this is usually not the case. There’s a huge chance we are overlooking something, and because tests cover only a finite set of inputs, the scope of bugs can be much greater than we expect. There are two things we can do immediately to improve code reliability and safety. One option has been realized by engineers (and scientists) since their early beginnings: external audits (and peer review). The second is a technique that is finally starting to be feasible in large-scale programs: <em>verification</em>. Verification techniques are the topic of ongoing research, but we can use some of them <em>today</em>.</p>
<p>There’s one takeaway that can never be emphasized too much: we should be cautious when writing our code, because poor design choices can “explode” in the future. Ideally, we <em>specify</em> first what we are actually about to program, and only then start working on the implementation. This is the simple idea behind specification-driven development: we are writing programs and proofs of their correctness <em>at the same time</em>. The question that remains is, how do we write good specifications? What should we look out for? How can we be sure that our specification is sufficient and why is operational semantics important? We are going to look at this in the follow-up article.</p>
<h2 id="references">References</h2>
<p>[1] RUMSFELD, Donald. <a href="https://archive.today/20180320091111/http://archive.defense.gov/Transcripts/Transcript.aspx?TranscriptID=2636">“Defense.gov News Transcript: DoD News Briefing – Secretary Rumsfeld and Gen. Myers, United States Department of Defense (defense.gov)”</a>. February 12, 2002. Archived from <a href="http://archive.defense.gov/Transcripts/Transcript.aspx?TranscriptID=2636">the original</a> on March 20, 2018.</p>
<p>[2] ZIZEK, Slavoj. <a href="http://www.lacan.com/zizekrumsfeld.htm">“What Rumsfeld Doesn’t Know That He Knows About Abu Ghraib”</a>. Retrieved February 23, 2009.</p>
<p><em>Originally published at <a href="https://runtimeverification.com/blog/warning-code-can-be-explosive">https://runtimeverification.com</a> on October 12, 2022.</em></p>
    </section>
    
    <section class="footer">
        <div class="line"></div>
        Read more articles on: <a href="../topics/smart-contracts">smart-contracts</a>, <a href="../topics/verification">verification</a>, <a href="../topics/specifications">specifications</a>, <a href="../topics/testing">testing</a>, <a href="../topics/fuzzing">fuzzing</a>, <a href="../topics/symbolic-execution">symbolic-execution</a>, <a href="../topics/audits">audits</a>.
    </section>
    
</article>

            <p>
                <a href="#" class="btn up"><i class="fa fa-arrow-up"></i>
                <span class="sr-only">Go up</span></a>
            </p>
        </div>
    </main>
    <footer>
        <div class="body">
            &copy; Adam Fiedler 2023
            <div class="heart">
                Running with &hearts; on
                <a href="https://jaspervdj.be/hakyll">Hakyll</a>. Here's the <a href="https://github.com/fiedlr/fiedlr">source</a>.
            </div>
        </div>
    </footer>
    
</body>
</html>
